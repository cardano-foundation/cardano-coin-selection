{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"cardano-coin-selection","text":"<p>Coin selection algorithms for the Cardano blockchain.</p> <p>This library provides a complete solution for selecting UTxO entries to fund transactions on Cardano, including multi-asset support, change generation, fee estimation, minting/burning, and collateral selection.</p>"},{"location":"#modules","title":"Modules","text":"Module Purpose <code>Cardano.CoinSelection</code> High-level entry point combining balance and collateral selection <code>Cardano.CoinSelection.Balance</code> Random-Round-Robin algorithm for multi-asset UTxO sets <code>Cardano.CoinSelection.Collateral</code> Dual-strategy collateral selection <code>Cardano.CoinSelection.UTxOIndex</code> Asset-indexed UTxO set with efficient asset-indexed lookup <code>Cardano.CoinSelection.UTxOSelection</code> Selected/leftover state machine <code>Cardano.CoinSelection.Context</code> Type class for selection contexts <code>Cardano.CoinSelection.Size</code> Token bundle size assessment"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started -- installation and basic usage</li> <li>Tutorial -- step-by-step coin selection walkthrough</li> <li>Selection Strategies -- Optimal vs Minimal</li> <li>UTxO Index -- the core data structure</li> <li>References -- papers and blog posts</li> </ul>"},{"location":"#design-principles","title":"Design principles","text":"<p>The coin selection algorithm is designed around several key principles:</p> <ol> <li> <p>Self-organisation: the UTxO set should evolve over time to resemble the    typical distribution of payments made by the wallet owner, increasing the    likelihood that future selections succeed.</p> </li> <li> <p>Privacy: change outputs should be roughly the same size and shape as    user-specified outputs, making it harder for an observer to distinguish    change from payments.</p> </li> <li> <p>Efficiency: the algorithm must terminate in bounded time and produce    selections that minimise fees.</p> </li> <li> <p>Correctness: all selections satisfy a set of formally verified    properties -- checked by the test suite via QuickCheck.</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add <code>cardano-coin-selection</code> to your <code>build-depends</code> in your <code>.cabal</code> file:</p> <pre><code>build-depends:\n    , cardano-coin-selection\n</code></pre> <p>The package is available from the Cardano Haskell Package repository (CHaP).</p> <p>Add CHaP to your <code>cabal.project</code>:</p> <pre><code>repository cardano-haskell-packages\n  url: https://chap.intersectmbo.org/\n  secure: True\n</code></pre>"},{"location":"getting-started/#module-imports","title":"Module imports","text":"<p>The library is designed around qualified imports:</p> <pre><code>import qualified Cardano.CoinSelection as CS\nimport qualified Cardano.CoinSelection.Balance as Balance\nimport qualified Cardano.CoinSelection.Collateral as Collateral\nimport qualified Cardano.CoinSelection.UTxOIndex as UTxOIndex\nimport qualified Cardano.CoinSelection.UTxOSelection as UTxOSelection\n</code></pre>"},{"location":"getting-started/#defining-a-selection-context","title":"Defining a selection context","text":"<p>Before performing a selection, you need to define a <code>SelectionContext</code> that specifies your address and UTxO identifier types:</p> <pre><code>data MyContext\n\ninstance SelectionContext MyContext where\n    type Address MyContext = MyAddress\n    type UTxO    MyContext = MyTxIn\n</code></pre> <p>The only requirements are that both associated types have <code>Ord</code> and <code>Show</code> instances.</p>"},{"location":"getting-started/#performing-a-selection","title":"Performing a selection","text":"<p>The main entry point is <code>Cardano.CoinSelection.performSelection</code>:</p> <pre><code>import Cardano.CoinSelection\n    ( Selection\n    , SelectionConstraints (..)\n    , SelectionError\n    , SelectionParams (..)\n    , performSelection\n    )\n\nresult &lt;- runExceptT $ performSelection constraints params\n-- result :: Either (SelectionError MyContext) (Selection MyContext)\n</code></pre> <p>The <code>performSelection</code> function:</p> <ol> <li>Selects inputs from the UTxO set to cover user-specified outputs</li> <li>Selects inputs to cover collateral (if required)</li> <li>Produces change outputs to return excess value</li> <li>Balances the selection to pay for the transaction fee</li> </ol> <p>See the Tutorial for a complete worked example.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/#blog-posts","title":"Blog posts","text":"<ul> <li> <p>Self Organisation in Coin Selection   (IOHK blog)   -- describes how random coin selection leads to a self-organising UTxO   distribution that mirrors the user's payment patterns.</p> </li> <li> <p>The Challenges of Optimizing Unspent Output Selection   (Jameson Lopp)   -- a survey of coin selection approaches for Bitcoin, many of which apply   to Cardano's UTxO model.</p> </li> </ul>"},{"location":"references/#cardano-documentation","title":"Cardano documentation","text":"<ul> <li> <p>Cardano Wallet User Guide   (GitHub Pages)   -- the full documentation for the cardano-wallet project, which uses   this coin selection library.</p> </li> <li> <p>Cardano Ledger Specification   (GitHub)   -- the formal specification of the Cardano ledger, including transaction   validation rules that constrain coin selection.</p> </li> </ul>"},{"location":"references/#primitives","title":"Primitives","text":"<p>This library ships its own primitive types and numeric utilities -- there are no external dependencies on <code>cardano-numeric</code> or <code>cardano-wallet-primitive</code>. Types such as <code>TokenMap</code>, <code>TokenBundle</code>, and <code>Coin</code>, as well as functions like <code>partitionNatural</code> and <code>equipartitionNatural</code>, are all defined within this package.</p>"},{"location":"references/#haddock-documentation","title":"Haddock documentation","text":"<p>The most detailed documentation is in the Haddock comments within the source code itself:</p> Module Key documentation <code>Cardano.CoinSelection.Balance</code> Round-robin algorithm, change generation, minting/burning <code>Cardano.CoinSelection.Collateral</code> Dual-strategy collateral selection <code>Cardano.CoinSelection.UTxOIndex.Internal</code> Index invariants, selection filters <code>Cardano.CoinSelection.UTxOSelection</code> State machine semantics <code>Cardano.CoinSelection.Internal.Numeric</code> padCoalesce, partitionNatural proofs <code>Cardano.CoinSelection.Types.TokenMap</code> Partial ordering rationale"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial walks through a complete coin selection from start to finish.</p>"},{"location":"tutorial/#scenario","title":"Scenario","text":"<p>Alice has a wallet with the following UTxO set and wants to send 15 ada and 3 tokens of asset X to Bob.</p>"},{"location":"tutorial/#alices-utxo-set","title":"Alice's UTxO set","text":"UTxO Ada Asset X u1 10 0 u2 5 2 u3 20 0 u4 3 5"},{"location":"tutorial/#desired-output","title":"Desired output","text":"Recipient Ada Asset X Bob 15 3"},{"location":"tutorial/#step-1-build-the-utxo-index","title":"Step 1: Build the UTxO index","text":"<p>The first step is to build a <code>UTxOIndex</code> from Alice's UTxO set. The index maintains a mapping from each asset to the subset of UTxOs containing that asset, enabling efficient random selection.</p> <pre><code>let utxoIndex = UTxOIndex.fromMap $ Map.fromList\n        [ (u1, TokenBundle (Coin 10) mempty)\n        , (u2, TokenBundle (Coin 5)  (TokenMap.singleton assetX (TokenQuantity 2)))\n        , (u3, TokenBundle (Coin 20) mempty)\n        , (u4, TokenBundle (Coin 3)  (TokenMap.singleton assetX (TokenQuantity 5)))\n        ]\n</code></pre>"},{"location":"tutorial/#step-2-configure-selection-parameters","title":"Step 2: Configure selection parameters","text":"<pre><code>let params = SelectionParams\n        { outputsToCover =\n            [ (bobAddress, TokenBundle (Coin 15)\n                (TokenMap.singleton assetX (TokenQuantity 3)))\n            ]\n        , utxoAvailableForInputs = UTxOSelection.fromIndex utxoIndex\n        , utxoAvailableForCollateral = mempty\n        , collateralRequirement = SelectionCollateralNotRequired\n        , extraCoinIn  = Coin 0\n        , extraCoinOut = Coin 0\n        , assetsToMint = mempty\n        , assetsToBurn = mempty\n        , selectionStrategy = SelectionStrategyOptimal\n        }\n</code></pre>"},{"location":"tutorial/#step-3-the-selection-algorithm-runs","title":"Step 3: The selection algorithm runs","text":"<p>Internally, the algorithm proceeds through several phases:</p>"},{"location":"tutorial/#phase-1-random-round-robin-selection","title":"Phase 1: Random-Round-Robin selection","text":"<pre><code>flowchart TD\n    A[Start with empty selection] --&gt; B{Any asset below target?}\n    B --&gt;|Yes| C[Pick asset with largest deficit]\n    C --&gt; D[Randomly select UTxO containing that asset]\n    D --&gt; E[Move UTxO from leftover to selected]\n    E --&gt; B\n    B --&gt;|No| F{Ada below target?}\n    F --&gt;|Yes| G[Randomly select ada-only UTxO]\n    G --&gt; E\n    F --&gt;|No| H[Selection complete]</code></pre> <p>With the Optimal strategy, the algorithm targets twice the minimum required amount of each asset. This produces change outputs that are roughly the same size as the user-specified outputs.</p> <p>For our example, the algorithm needs at least 3 tokens of asset X. With the optimal strategy it targets 6. It might select:</p> <ul> <li>u4 (3 ada, 5 asset X) -- provides 5 of the targeted 6 asset X</li> <li>u2 (5 ada, 2 asset X) -- provides 2 more asset X (total: 7, close to target 6)</li> <li>u3 (20 ada) -- provides additional ada to reach the ada target</li> </ul>"},{"location":"tutorial/#phase-2-change-generation","title":"Phase 2: Change generation","text":"<p>Once inputs are selected, the algorithm computes change:</p> \\[ \\text{change} = \\sum \\text{inputs} + \\text{mints} - \\sum \\text{outputs} - \\text{burns} - \\text{fee} \\] <p>For our example (assuming fee = 0.2 ada):</p> Ada Asset X Inputs (u2 + u3 + u4) 28 7 Outputs (Bob) -15 -3 Fee -0.2 0 Change 12.8 4 <p>The change is distributed proportionally to the original outputs. Since there is only one output, all change goes into a single change output sent back to Alice.</p>"},{"location":"tutorial/#phase-3-fee-estimation-loop","title":"Phase 3: Fee estimation loop","text":"<p>There is a chicken-and-egg problem: we need to know the fee to compute change, but we need to know the change to compute the fee (since change affects transaction size).</p> <pre><code>flowchart TD\n    A[Predict change shape with zero fee] --&gt; B[Estimate fee from skeleton]\n    B --&gt; C[Compute actual change with estimated fee]\n    C --&gt; D{Enough ada for change + fee?}\n    D --&gt;|Yes| E[Done]\n    D --&gt;|No| F[Select one more ada-only input]\n    F --&gt; B</code></pre> <p>The algorithm resolves this by:</p> <ol> <li>First computing a \"prediction\" of change with zero fees</li> <li>Using that prediction to estimate the fee</li> <li>Then computing actual change with the real fee</li> <li>If ada is insufficient, selecting one more input and repeating</li> </ol>"},{"location":"tutorial/#step-4-inspect-the-result","title":"Step 4: Inspect the result","text":"<pre><code>case result of\n    Left err -&gt; handleError err\n    Right selection -&gt; do\n        -- Selected inputs (non-empty list)\n        let inputs = CS.inputs selection\n\n        -- User-specified outputs\n        let outputs = CS.outputs selection\n\n        -- Generated change outputs (sent back to Alice)\n        let change = CS.change selection\n\n        -- The selection surplus covers the fee\n        let surplus = CS.selectionDeltaAllAssets selection\n</code></pre>"},{"location":"tutorial/#summary","title":"Summary","text":"<p>The coin selection algorithm balances several competing concerns:</p> <ul> <li>Covering the outputs: enough value must be selected</li> <li>Minimising fees: don't select unnecessarily many inputs</li> <li>Self-organisation: target ~2x the minimum to produce useful change</li> <li>Privacy: change should resemble typical outputs</li> <li>Correctness: all invariants are maintained and verified</li> </ul>"},{"location":"concepts/change-generation/","title":"Change Generation","text":"<p>After selecting inputs, the algorithm must distribute the excess value into change outputs that are sent back to the wallet. This is handled by the <code>makeChange</code> function.</p>"},{"location":"concepts/change-generation/#the-chicken-and-egg-problem","title":"The chicken-and-egg problem","text":"<p>There is a circular dependency between change and fees:</p> <ul> <li>To compute the fee, we need to know the transaction size, which depends   on the change outputs.</li> <li>To compute the change, we need to subtract the fee from the excess   value.</li> </ul> <pre><code>flowchart LR\n    A[Change outputs] --&gt;|affect| B[Transaction size]\n    B --&gt;|determines| C[Fee]\n    C --&gt;|affects| A</code></pre>"},{"location":"concepts/change-generation/#resolution","title":"Resolution","text":"<p>The algorithm resolves this with a two-phase approach:</p> <ol> <li> <p>Predict change shape -- call <code>makeChange</code> with zero fees and zero    minimum ada quantities. This always succeeds and yields the correct    asset composition of change (but not the correct ada amounts).</p> </li> <li> <p>Estimate fee from skeleton -- use the predicted change shape (number    of change outputs and their asset sets) to estimate the transaction fee.</p> </li> <li> <p>Compute actual change -- call <code>makeChange</code> with the estimated fee and    real minimum ada quantities.</p> </li> <li> <p>Retry if needed -- if there isn't enough ada to cover both the fee and    the minimum ada quantities of change outputs, select one more ada-only input    and repeat from step 2.</p> </li> </ol> <pre><code>flowchart TD\n    A[Predict change with fee=0] --&gt; B[Compute fee from skeleton]\n    B --&gt; C[Compute actual change]\n    C --&gt; D{Enough ada?}\n    D --&gt;|Yes| E[Return selection result]\n    D --&gt;|No| F{More ada-only UTxOs available?}\n    F --&gt;|Yes| G[Select one more ada-only UTxO]\n    G --&gt; B\n    F --&gt;|No| H[Return UnableToConstructChange error]</code></pre>"},{"location":"concepts/change-generation/#change-for-user-specified-assets","title":"Change for user-specified assets","text":"<p>For assets that appear in the user's requested outputs, the change quantity is distributed proportionally to the original output weights.</p> <p>Given an excess quantity \\(e\\) of asset \\(a\\) and output weights \\(w_1, w_2, \\ldots, w_n\\):</p> \\[ \\text{change}_i = \\left\\lfloor e \\cdot \\frac{w_i}{\\sum_j w_j} \\right\\rfloor + r_i \\] <p>where \\(r_i \\in \\{0, 1\\}\\) are rounding corrections ensuring the total equals \\(e\\) exactly. See Partitioning for details.</p>"},{"location":"concepts/change-generation/#change-for-non-user-specified-assets","title":"Change for non-user-specified assets","text":"<p>Assets that were not in the original outputs but were selected as side effects (because they shared a UTxO with a desired asset) are distributed using the padCoalesce algorithm.</p> <p>These change maps are sorted in ascending partial order, which ensures that when combined with user-specified change maps, the smallest maps are merged with the smallest maps.</p>"},{"location":"concepts/change-generation/#assigning-ada-to-change-maps","title":"Assigning ada to change maps","text":"<p>After computing the asset change maps, the algorithm assigns ada quantities:</p> <ol> <li> <p>Assign the minimum required ada to each change map (based on its token    bundle size).</p> </li> <li> <p>Distribute any remaining ada proportionally to the original output    coins.</p> </li> </ol> <p>If there isn't enough ada to cover all minimum quantities, the algorithm drops empty change maps (those with no native tokens) from the start of the list, reducing the total minimum ada required.</p> <p>Invariant</p> <p>The number of change outputs is at least the number of user-specified outputs (unless ada is insufficient to fund that many change outputs).</p>"},{"location":"concepts/change-generation/#splitting-oversized-change","title":"Splitting oversized change","text":"<p>If a change output exceeds the maximum allowed token bundle size, it is split into smaller bundles using <code>equipartitionAssets</code>. If any individual token quantity exceeds the protocol maximum, it is split using <code>equipartitionQuantitiesWithUpperBound</code>.</p>"},{"location":"concepts/collateral/","title":"Collateral Selection","text":"<p>Plutus script transactions on Cardano require collateral -- a set of ada-only UTxOs that will be forfeited if the script fails validation. The <code>Cardano.CoinSelection.Collateral</code> module provides a dedicated algorithm for selecting collateral.</p>"},{"location":"concepts/collateral/#requirements","title":"Requirements","text":"<p>The protocol imposes two constraints on collateral:</p> <ol> <li>Size: at most <code>maximumCollateralInputCount</code> UTxOs can be used</li> <li>Value: the total value must be at least    <code>minimumCollateralPercentage</code>% of the transaction fee</li> </ol> \\[ \\text{collateral} \\geq \\left\\lceil \\frac{\\text{fee} \\times \\text{percentage}}{100} \\right\\rceil \\]"},{"location":"concepts/collateral/#dual-strategy-approach","title":"Dual-strategy approach","text":"<p>The algorithm tries two strategies in sequence, picking the first that succeeds:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Strategy 1: Smallest-first]\n    B --&gt; C{Succeeded?}\n    C --&gt;|Yes| D[Return smallest selection]\n    C --&gt;|No| E[Strategy 2: Largest-first]\n    E --&gt; F{Succeeded?}\n    F --&gt;|Yes| G[Return largest selection]\n    F --&gt;|No| H[Return error with largest combination]</code></pre>"},{"location":"concepts/collateral/#strategy-1-smallest-first","title":"Strategy 1: Smallest-first","text":"<p>This strategy produces an optimal result -- the smallest possible total collateral amount.</p> <ol> <li>Sort available coins in ascending order</li> <li>Trim the list: discard coins after the first one that individually exceeds    the minimum</li> <li>Enumerate all combinations of size 1, 2, ..., up to <code>maximumSelectionSize</code></li> <li>For each size, find the smallest combination that meets the minimum</li> <li>Return the overall smallest valid combination</li> </ol> <p>Search space limit</p> <p>The number of combinations can be exponential. The algorithm guards against this with a configurable <code>searchSpaceLimit</code> (default: 1,000,000). If the required search space exceeds this limit, the strategy fails without computing a result.</p> <p>The search space for selecting \\(k\\) coins from \\(n\\) available is:</p> \\[ \\binom{n}{k} = \\frac{n!}{k!(n-k)!} \\]"},{"location":"concepts/collateral/#strategy-2-largest-first","title":"Strategy 2: Largest-first","text":"<p>This fallback strategy always produces a result if one exists:</p> <ol> <li>Take the <code>maximumSelectionSize</code> largest coins</li> <li>Enumerate all submaps of this small set (at most \\(2^k\\) submaps where    \\(k \\leq\\) <code>maximumSelectionSize</code>, typically 3)</li> <li>Return the smallest submap that meets the minimum</li> </ol> <p>Since <code>maximumSelectionSize</code> is typically very small (3), this strategy is always fast.</p>"},{"location":"concepts/collateral/#properties","title":"Properties","text":"<p>If the selection succeeds, the result satisfies:</p> \\[ \\begin{aligned} \\sum \\text{coinsSelected} &amp;\\geq \\text{minimumSelectionAmount} \\\\ |\\text{coinsSelected}| &amp;\\leq \\text{maximumSelectionSize} \\\\ \\text{coinsSelected} &amp;\\subseteq \\text{coinsAvailable} \\end{aligned} \\] <p>If the selection fails, the error reports:</p> \\[ \\begin{aligned} \\sum \\text{largestCombination} &amp;&lt; \\text{minimumSelectionAmount} \\\\ |\\text{largestCombination}| &amp;\\leq \\text{maximumSelectionSize} \\\\ \\text{largestCombination} &amp;\\subseteq \\text{coinsAvailable} \\end{aligned} \\]"},{"location":"concepts/collateral/#integration-with-balance-selection","title":"Integration with balance selection","text":"<p>Collateral selection runs after the main balance selection. The balance selection reserves space for collateral inputs ahead of time by adding <code>maximumCollateralInputCount</code> to the skeleton input count when estimating fees.</p> <p>This ensures the fee already accounts for the collateral inputs, even though the exact collateral UTxOs are not yet known. The slight overestimation (since fewer collateral inputs may actually be needed) results in a marginally higher fee, which is acceptable given the small size of <code>maximumCollateralInputCount</code>.</p>"},{"location":"concepts/minting-burning/","title":"Minting and Burning","text":"<p>Transactions on Cardano can mint (create) and burn (destroy) native tokens. These operations interact with coin selection because they change the value balance of the transaction.</p>"},{"location":"concepts/minting-burning/#minting-as-extra-input","title":"Minting as extra input","text":"<p>Minting tokens provides input value from \"the void\":</p> \\[ \\text{total input} = \\sum \\text{UTxO inputs} + \\text{extra ada source} + \\text{minted tokens} \\] <p>By minting tokens, we decrease the burden on the selection algorithm -- fewer UTxO entries need to be selected.</p>"},{"location":"concepts/minting-burning/#burning-as-extra-output","title":"Burning as extra output","text":"<p>Burning tokens consumes output value to \"the void\":</p> \\[ \\text{total output} = \\sum \\text{user outputs} + \\text{extra ada sink} + \\text{burned tokens} \\] <p>By burning tokens, we increase the burden on the selection algorithm -- more UTxO entries are needed.</p>"},{"location":"concepts/minting-burning/#integration-with-change-generation","title":"Integration with change generation","text":"<p>Minted and burned tokens are integrated into the change generation process for non-user-specified assets (assets that were not in the original output set).</p>"},{"location":"concepts/minting-burning/#key-properties","title":"Key properties","text":"<p>The change bundles must maintain these properties throughout minting and burning operations:</p> <ol> <li>The number of change bundles equals the number of user-specified outputs</li> <li>The change bundles are in ascending partial order</li> <li>The change bundles maximise the number of large bundles</li> </ol>"},{"location":"concepts/minting-burning/#adding-minted-values","title":"Adding minted values","text":"<p>Minted tokens are added to the largest change bundle (the last element in the ascending-ordered list):</p> <pre><code>Before minting 4 of asset A:\n\n    [ [          (\"B\",  7) ]\n    [ [(\"A\", 1), (\"B\",  8) ]\n    [ [(\"A\", 2), (\"B\",  9) ]\n    [ [(\"A\", 3), (\"B\",  9) ]\n    [ [(\"A\", 4), (\"B\", 12) ]   &lt;-- add here\n\nAfter:\n\n    [ [          (\"B\",  7) ]\n    [ [(\"A\", 1), (\"B\",  8) ]\n    [ [(\"A\", 2), (\"B\",  9) ]\n    [ [(\"A\", 3), (\"B\",  9) ]\n    [ [(\"A\", 8), (\"B\", 12) ]   &lt;-- increased by 4\n</code></pre> <p>Adding to the largest bundle trivially maintains the ascending partial order.</p>"},{"location":"concepts/minting-burning/#removing-burned-values","title":"Removing burned values","text":"<p>Burned tokens are removed from the smallest change bundles first, traversing left to right:</p> <pre><code>Before burning 4 of asset A:\n\n    [ [          (\"B\",  7) ]   &lt;-- start here (already 0)\n    [ [(\"A\", 1), (\"B\",  8) ]   &lt;-- reduce by 1\n    [ [(\"A\", 2), (\"B\",  9) ]   &lt;-- reduce by 2\n    [ [(\"A\", 3), (\"B\",  9) ]   &lt;-- reduce by 1\n    [ [(\"A\", 4), (\"B\", 12) ]\n\nAfter:\n\n    [ [          (\"B\",  7) ]   &lt;-- unchanged (was already 0)\n    [ [          (\"B\",  8) ]   &lt;-- reduced by 1, eliminated\n    [ [          (\"B\",  9) ]   &lt;-- reduced by 2, eliminated\n    [ [(\"A\", 2), (\"B\",  9) ]   &lt;-- reduced by 1\n    [ [(\"A\", 4), (\"B\", 12) ]\n</code></pre> <p>Why smallest first?</p> <p>Removing from the smallest bundles preserves the ascending partial order and removes the \"least useful\" bundles first, maximising the overall usefulness of the remaining change.</p>"},{"location":"concepts/minting-burning/#formal-property-ascending-partial-order","title":"Formal property: ascending partial order","text":"<p>For a list of token maps \\([m_1, m_2, \\ldots, m_n]\\) to be in ascending partial order, we require:</p> \\[ \\forall\\, i &lt; j: \\quad m_i \\leq m_j \\] <p>where \\(\\leq\\) is the partial order on <code>TokenMap</code> (every quantity in \\(m_i\\) is less than or equal to its counterpart in \\(m_j\\)).</p> <p>Both the minting and burning operations preserve this property, as proven by the following arguments:</p> <ul> <li> <p>Minting: adding to the maximum element cannot violate the ordering of   any pair \\((m_i, m_n)\\) since \\(m_n\\) only increases.</p> </li> <li> <p>Burning: reducing from left to right reduces \\(m_i\\) by at most \\(q_i\\)   (its own quantity), so \\(m_i \\leq m_{i+1}\\) is maintained because \\(m_{i+1}\\)   is reduced by a smaller or equal amount.</p> </li> </ul>"},{"location":"concepts/selection-strategies/","title":"Selection Strategies","text":"<p>The library provides two selection strategies that control how much of each asset the algorithm selects relative to the minimum required.</p>"},{"location":"concepts/selection-strategies/#selectionstrategyoptimal","title":"SelectionStrategyOptimal","text":"<p>The default strategy. For each asset, the algorithm targets approximately twice the minimum required amount:</p> \\[ \\text{target}(a) = 2 \\times \\text{minimum}(a) \\] <p>This means that after paying for the required outputs, the remaining value is returned as change that is roughly the same size as the original outputs.</p> <p>When to use</p> <p>Use for most transactions. This strategy helps the wallet's UTxO distribution evolve to match the user's typical payment patterns, increasing the likelihood that future selections succeed and lowering amortized transaction costs.</p>"},{"location":"concepts/selection-strategies/#example","title":"Example","text":"<p>If the user sends 100 ada, the algorithm targets selecting ~200 ada worth of inputs, producing ~100 ada in change. This change output is similar in size to the payment, maintaining a balanced UTxO set.</p>"},{"location":"concepts/selection-strategies/#selectionstrategyminimal","title":"SelectionStrategyMinimal","text":"<p>Selects just enough of each asset to meet the minimum required:</p> \\[ \\text{target}(a) = 1 \\times \\text{minimum}(a) \\] <p>The selection terminates as soon as the minimum is covered.</p> <p>When to use</p> <p>Use only as a fallback when the optimal strategy fails. Regular use of the minimal strategy leads to small, fragmented change outputs that degrade the wallet's UTxO set over time.</p>"},{"location":"concepts/selection-strategies/#example_1","title":"Example","text":"<p>If the user sends 100 ada, the algorithm selects ~100 ada of inputs, producing very little change. The small change outputs are less useful for future transactions.</p>"},{"location":"concepts/selection-strategies/#the-round-robin-algorithm","title":"The Round-Robin algorithm","text":"<p>Both strategies share the same underlying Random-Round-Robin algorithm. The algorithm processes each asset in turn, selecting UTxOs randomly until all assets reach their target.</p> <pre><code>flowchart TD\n    A[Build selector for each asset] --&gt; B[Reverse list, ada selector last]\n    B --&gt; C{Any selector can improve?}\n    C --&gt;|Yes| D[Run next selector]\n    D --&gt; E{Improvement?}\n    E --&gt;|Yes| F[Keep selector in queue]\n    E --&gt;|No| G[Remove selector from queue]\n    F --&gt; C\n    G --&gt; C\n    C --&gt;|No| H[Selection complete]</code></pre>"},{"location":"concepts/selection-strategies/#selection-step-logic","title":"Selection step logic","text":"<p>For a given asset, a single selection step works as follows:</p> <ol> <li> <p>If the current selected quantity is below the minimum, select another    UTxO containing that asset.</p> </li> <li> <p>If the current selected quantity is at or above the minimum, select    another UTxO only if it brings the total closer to the target (but not    further away).</p> </li> </ol> \\[ \\text{improvement}(s') = |q(s') - \\text{target}| &lt; |q(s) - \\text{target}| \\] <p>where \\(q(s)\\) is the selected quantity of the asset in state \\(s\\).</p>"},{"location":"concepts/selection-strategies/#utxo-selection-priority","title":"UTxO selection priority","text":"<p>When selecting a UTxO for a given asset \\(a\\), the algorithm tries these filters in order of priority:</p> <ol> <li>Singleton: a UTxO containing only asset \\(a\\) (and ada)</li> <li>Pair: a UTxO containing asset \\(a\\) and exactly one other asset</li> <li>Any: any UTxO containing asset \\(a\\)</li> </ol> <p>This priority order minimises \"collateral damage\" -- the selection of unwanted assets alongside the desired one.</p>"},{"location":"concepts/selection-strategies/#ada-is-selected-last","title":"Ada is selected last","text":"<p>The ada selector is run last in the round-robin. Since every UTxO necessarily contains ada, selecting UTxOs for other assets first increases the probability that the ada requirement is already satisfied without needing additional ada-only inputs.</p>"},{"location":"concepts/utxo-model/","title":"The UTxO Model","text":""},{"location":"concepts/utxo-model/#utxo-vs-account-model","title":"UTxO vs Account model","text":"<p>Cardano uses the UTxO (Unspent Transaction Output) model, in contrast to the account-based model used by Ethereum. In the UTxO model, value is stored in discrete, indivisible outputs -- analogous to banknotes.</p> <p>Key property</p> <p>A UTxO can only be spent once, in its entirety. You cannot spend part of a UTxO -- you must consume the whole thing and return any excess as change.</p>"},{"location":"concepts/utxo-model/#analogy-with-cash","title":"Analogy with cash","text":"Cash UTxO Pay with a $20 note Consume a UTxO as a transaction input Receive change Create a change output Can't use the same note twice A UTxO can only be spent once Can't split a note in two shops Must wait for change before spending it"},{"location":"concepts/utxo-model/#consequences","title":"Consequences","text":"<p>Because each UTxO is indivisible:</p> <ul> <li> <p>Concurrency: having many UTxOs allows more transactions to be made in   parallel. With only one large UTxO, you can only send one transaction at a   time (and must wait for change).</p> </li> <li> <p>Privacy: each time you spend from an address, that address and its   spending key are exposed. Address reuse weakens privacy.</p> </li> <li> <p>Fragmentation: creating too many small UTxOs (\"dust\") makes future   transactions more expensive, since more inputs are needed to reach the   required amount.</p> </li> </ul>"},{"location":"concepts/utxo-model/#why-coin-selection-matters","title":"Why coin selection matters","text":"<p>For every transaction, the wallet must decide which UTxOs to consume as inputs. This is the coin selection problem. A good algorithm must:</p> <ol> <li> <p>Cover the required amount -- the total value of selected inputs must be    at least the total value of all outputs plus the transaction fee.</p> </li> <li> <p>Respect transaction size limits -- the protocol limits the maximum    transaction size, which in turn limits the number of inputs and outputs.</p> </li> <li> <p>Maintain a healthy UTxO set -- the selection strategy should ensure that    the wallet's UTxO distribution evolves over time to remain useful for future    transactions.</p> </li> <li> <p>Preserve privacy -- change outputs should not be easily distinguishable    from payment outputs by an outside observer.</p> </li> </ol>"},{"location":"concepts/utxo-model/#multi-asset-utxos","title":"Multi-asset UTxOs","text":"<p>On Cardano, a single UTxO can carry ada (lovelace) and any number of native tokens. This makes coin selection significantly more complex than on Bitcoin, where each UTxO only carries a single asset.</p> <p>The coin selection algorithm must satisfy requirements for all assets simultaneously -- it is not sufficient to handle each asset independently.</p> <p>Minimum ada requirement</p> <p>Every UTxO on Cardano must contain a minimum amount of ada, determined by the size of its token bundle. UTxOs carrying many different native tokens require more ada. The coin selection algorithm must account for this when generating change outputs.</p>"},{"location":"data-structures/utxo-index/","title":"UTxO Index","text":"<p>The <code>UTxOIndex</code> is the core data structure powering coin selection. It indexes a UTxO set by asset identifier, enabling efficient lookup and random selection of UTxOs containing a particular asset.</p>"},{"location":"data-structures/utxo-index/#problem","title":"Problem","text":"<p>Given a UTxO set with thousands of entries, the selection algorithm needs to repeatedly find a UTxO containing a specific asset. A naive linear scan is \\(O(n)\\) per lookup, making the overall selection \\(O(n \\cdot k)\\) where \\(k\\) is the number of distinct assets.</p>"},{"location":"data-structures/utxo-index/#solution","title":"Solution","text":"<p>The <code>UTxOIndex</code> maintains several indices over the same UTxO set:</p> <pre><code>data UTxOIndex u = UTxOIndex\n    { indexAll        :: MonoidMap Asset (Set u)\n    , indexSingletons :: MonoidMap Asset (Set u)\n    , indexPairs      :: MonoidMap Asset (Set u)\n    , balance         :: TokenBundle\n    , universe        :: Map u TokenBundle\n    }\n</code></pre> Field Description <code>indexAll</code> All UTxOs containing a given asset <code>indexSingletons</code> UTxOs containing only that asset (plus ada) <code>indexPairs</code> UTxOs containing that asset and exactly one other <code>balance</code> Total balance across all entries <code>universe</code> Complete mapping from UTxO id to value"},{"location":"data-structures/utxo-index/#selection-filters","title":"Selection filters","text":"<p>The index supports four selection filters, tried in priority order:</p> <pre><code>data SelectionFilter asset\n    = SelectSingleton asset    -- UTxO with only this asset\n    | SelectPairWith  asset    -- UTxO with this asset + one other\n    | SelectAnyWith   asset    -- Any UTxO with this asset\n    | SelectAny                -- Any UTxO regardless of assets\n</code></pre>"},{"location":"data-structures/utxo-index/#why-this-priority","title":"Why this priority?","text":"<p>Selecting a UTxO that contains only the desired asset avoids \"collateral damage\" -- accidentally pulling in large quantities of unrelated assets.</p> Filter Collateral damage Use case <code>SelectSingleton</code> None Ideal: clean, targeted selection <code>SelectPairWith</code> Minimal (one extra asset) Good compromise <code>SelectAnyWith</code> Potentially high Fallback when others fail <code>SelectAny</code> Unpredictable Last resort: any UTxO at all"},{"location":"data-structures/utxo-index/#random-selection","title":"Random selection","text":"<pre><code>selectRandom\n    :: (MonadRandom m, Ord u)\n    =&gt; UTxOIndex u\n    -&gt; SelectionFilter Asset\n    -&gt; m (Maybe ((u, TokenBundle), UTxOIndex u))\n</code></pre> <p>The function:</p> <ol> <li>Looks up the set of UTxOs matching the filter</li> <li>Randomly selects one from the set</li> <li>Returns the selected UTxO and the index with that entry removed</li> </ol> <p>Random selection is key to the self-organising property of the algorithm -- over time, it produces a UTxO distribution that mirrors the user's payment patterns.</p>"},{"location":"data-structures/utxo-index/#selectrandomwithpriority","title":"selectRandomWithPriority","text":"<p>Tries a list of filters in order, returning the first successful selection:</p> <pre><code>selectRandomWithPriority\n    :: (MonadRandom m, Ord u)\n    =&gt; UTxOIndex u\n    -&gt; NonEmpty (SelectionFilter Asset)\n    -&gt; m (Maybe ((u, TokenBundle), UTxOIndex u))\n</code></pre>"},{"location":"data-structures/utxo-index/#operations","title":"Operations","text":"Operation Complexity Description <code>fromMap</code> \\(O(n \\cdot a)\\) Build from a <code>Map u TokenBundle</code> <code>insert</code> \\(O(\\log n \\cdot a)\\) Insert a single entry <code>delete</code> \\(O(\\log n \\cdot a)\\) Delete a single entry <code>lookup</code> \\(O(\\log n)\\) Look up a UTxO by id <code>balance</code> \\(O(1)\\) Total balance of all entries <code>size</code> \\(O(1)\\) Number of entries <code>assets</code> \\(O(k)\\) Set of all asset identifiers (\\(k\\) = distinct assets) <code>selectRandom</code> \\(O(\\log n \\cdot a)\\) Random selection with filter <p>where \\(n\\) is the number of UTxOs and \\(a\\) is the average number of assets per UTxO.</p>"},{"location":"data-structures/utxo-index/#invariant","title":"Invariant","text":"<p>The index maintains an internal invariant ensuring consistency between the universe (the complete map) and the various asset indices. This invariant is checked by <code>checkInvariant</code> and is verified in the test suite after every operation.</p> <p>The invariant ensures:</p> <ol> <li>Every UTxO in the universe appears in exactly the correct index entries</li> <li>The balance equals the sum of all values in the universe</li> <li>A UTxO appears in <code>indexSingletons</code> for asset \\(a\\) iff it contains only    asset \\(a\\) and ada</li> <li>A UTxO appears in <code>indexPairs</code> for asset \\(a\\) iff it contains asset \\(a\\)    and exactly one other non-ada asset</li> </ol>"},{"location":"data-structures/utxo-selection/","title":"UTxO Selection","text":"<p>The <code>UTxOSelection</code> type represents the state of a coin selection in progress. It tracks which UTxOs have been selected and which are still available.</p>"},{"location":"data-structures/utxo-selection/#structure","title":"Structure","text":"<p>A <code>UTxOSelection</code> consists of two disjoint <code>UTxOIndex</code> sets:</p> <pre><code>data State u = State\n    { leftover :: UTxOIndex u  -- UTxOs not yet selected\n    , selected :: UTxOIndex u  -- UTxOs already selected\n    }\n</code></pre> <pre><code>stateDiagram-v2\n    state UTxOSelection {\n        [*] --&gt; Leftover: fromIndex\n        Leftover --&gt; Selected: select\n    }\n    state Leftover {\n        note right of Leftover: UTxOs available\\nfor selection\n    }\n    state Selected {\n        note right of Selected: UTxOs already\\nchosen as inputs\n    }</code></pre>"},{"location":"data-structures/utxo-selection/#types","title":"Types","text":"<p>The module provides two types:</p> Type Guarantee <code>UTxOSelection u</code> May have zero selected entries <code>UTxOSelectionNonEmpty u</code> Has at least one selected entry <p>The <code>UTxOSelectionNonEmpty</code> type is used as evidence that the selection has made progress, which is important for constructing the final transaction (which requires at least one input).</p>"},{"location":"data-structures/utxo-selection/#construction","title":"Construction","text":"<pre><code>-- All UTxOs in the leftover set, none selected\nfromIndex :: UTxOIndex u -&gt; UTxOSelection u\n\n-- UTxOs matching the predicate are pre-selected\nfromIndexFiltered :: Ord u\n    =&gt; (u -&gt; Bool) -&gt; UTxOIndex u -&gt; UTxOSelection u\n\n-- Construct from explicit leftover/selected pair\nfromIndexPair :: Ord u\n    =&gt; (UTxOIndex u, UTxOIndex u) -&gt; UTxOSelection u\n</code></pre>"},{"location":"data-structures/utxo-selection/#core-operation-select","title":"Core operation: select","text":"<p>The <code>select</code> function moves a single UTxO from the leftover set to the selected set:</p> <pre><code>select :: (IsUTxOSelection s u, Ord u)\n    =&gt; u -&gt; s u -&gt; Maybe (UTxOSelectionNonEmpty u)\n</code></pre> <p>Polymorphic via <code>IsUTxOSelection</code></p> <p><code>select</code> is polymorphic over both <code>UTxOSelection</code> and <code>UTxOSelectionNonEmpty</code> via the <code>IsUTxOSelection</code> type class, so it can be called on either type.</p> <p>Key properties:</p> <ul> <li>Returns <code>Nothing</code> if the given UTxO is not in the leftover set</li> <li>Always returns <code>UTxOSelectionNonEmpty</code> (the selection is guaranteed   non-empty after a successful select)</li> <li>The total available balance remains constant:</li> </ul> \\[ \\text{availableBalance}(s) = \\text{availableBalance}(\\text{select}(u, s)) \\]"},{"location":"data-structures/utxo-selection/#balances","title":"Balances","text":"Function Returns <code>availableBalance</code> <code>selectedBalance + leftoverBalance</code> (constant) <code>selectedBalance</code> Balance of selected UTxOs <code>leftoverBalance</code> Balance of unselected UTxOs"},{"location":"data-structures/utxo-selection/#sub-selection-relation","title":"Sub-selection relation","text":"<p>A selection \\(s_1\\) is a sub-selection of \\(s_2\\) if \\(s_2\\) can be reached from \\(s_1\\) by zero or more applications of <code>select</code>:</p> \\[ s_1 \\subseteq s_2 \\iff \\exists\\, u_1, \\ldots, u_k: \\text{select}(u_k, \\ldots \\text{select}(u_1, s_1)\\ldots) = s_2 \\] <p>This relation is checked by <code>isSubSelectionOf</code> and is useful in property tests to verify that selections are consistent.</p>"},{"location":"data-structures/utxo-selection/#usage-in-coin-selection","title":"Usage in coin selection","text":"<p>The <code>UTxOSelection</code> is threaded through the entire selection process:</p> <ol> <li>Start: <code>fromIndex</code> creates a selection with all UTxOs as leftover</li> <li>Round-robin: each selection step calls <code>select</code> to move a UTxO from    leftover to selected</li> <li>Change generation: the selected set is used to compute the total input    value</li> <li>Result: the selected entries become the transaction inputs; the leftover    set is returned to the wallet</li> </ol>"},{"location":"math/coalescing/","title":"Coalescing: padCoalesce","text":"<p>The <code>padCoalesce</code> function adjusts a list to match a target length while preserving the total sum. It is used to distribute non-user-specified asset quantities across change outputs.</p>"},{"location":"math/coalescing/#definition","title":"Definition","text":"<p>Given a source list \\(S\\) and a target list \\(T\\):</p> \\[ \\text{padCoalesce}(S, T) = S' \\quad\\text{where}\\quad |S'| = |T| \\quad\\text{and}\\quad \\sum S' = \\sum S \\] <p>The result \\(S'\\) is always sorted in ascending order.</p>"},{"location":"math/coalescing/#algorithm","title":"Algorithm","text":"<p>The function first sorts the source list, then:</p> <ul> <li>If \\(|S| &lt; |T|\\): pad by inserting <code>mempty</code> until the lengths match</li> <li>If \\(|S| &gt; |T|\\): coalesce by merging the two smallest elements until   the lengths match</li> <li>If \\(|S| = |T|\\): return the sorted source unchanged</li> </ul>"},{"location":"math/coalescing/#padding","title":"Padding","text":"<p>Repeatedly insert <code>mempty</code> (zero) into the sorted list:</p> \\[ [a_1, a_2, \\ldots, a_k] \\xrightarrow{\\text{pad}} [0, a_1, a_2, \\ldots, a_k] \\] <p>Since \\(0 \\leq a_i\\) for all \\(i\\), the ascending order is preserved.</p>"},{"location":"math/coalescing/#coalescing","title":"Coalescing","text":"<p>Repeatedly merge the two smallest elements:</p> \\[ [a_1, a_2, a_3, \\ldots, a_k] \\xrightarrow{\\text{coalesce}} [a_3, \\ldots, (a_1 + a_2), \\ldots, a_k] \\] <p>The merged element \\((a_1 + a_2)\\) is re-inserted in sorted position. The sum is preserved because \\(a_1 + a_2\\) replaces both \\(a_1\\) and \\(a_2\\).</p>"},{"location":"math/coalescing/#examples","title":"Examples","text":"<pre><code>-- Padding: source shorter than target\n&gt;&gt;&gt; padCoalesce [Sum 1] (replicate 4 ())\n[Sum 0, Sum 0, Sum 0, Sum 1]\n\n-- Coalescing: source longer than target\n&gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 3 ())\n[Sum 3, Sum 4, Sum 8]\n\n&gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 2 ())\n[Sum 7, Sum 8]\n\n&gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 1 ())\n[Sum 15]\n</code></pre>"},{"location":"math/coalescing/#worked-example-coalescing-8-4-2-1-to-length-2","title":"Worked example: coalescing [8, 4, 2, 1] to length 2","text":"<ol> <li>Sort: \\([1, 2, 4, 8]\\), need to reduce from 4 to 2</li> <li>Coalesce smallest pair: \\(1 + 2 = 3\\), insert: \\([3, 4, 8]\\)</li> <li>Coalesce smallest pair: \\(3 + 4 = 7\\), insert: \\([7, 8]\\)</li> <li>Length matches target. Result: \\([7, 8]\\)</li> </ol> <p>Sum check: \\(1 + 2 + 4 + 8 = 15 = 7 + 8\\)</p>"},{"location":"math/coalescing/#properties","title":"Properties","text":"<ol> <li> <p>Length preservation: \\(|\\text{result}| = |\\text{target}|\\)</p> </li> <li> <p>Sum preservation: \\(\\sum \\text{result} = \\sum \\text{source}\\)</p> </li> <li> <p>Ascending order: the result is sorted in ascending order</p> </li> <li> <p>Maximises large values: coalescing the smallest pair at each step    ensures that large values are preserved as much as possible</p> </li> </ol>"},{"location":"math/coalescing/#usage-in-coin-selection","title":"Usage in coin selection","text":"<p><code>padCoalesce</code> is used by <code>makeChangeForNonUserSpecifiedAsset</code> to distribute the quantities of a non-user-specified asset across the correct number of change outputs.</p> <p>For example, if asset B was found in 9 selected UTxOs with quantities \\([9, 1, 8, 2, 7, 3, 6, 4, 5]\\) and the user requested 5 outputs, then <code>padCoalesce</code> reduces these 9 quantities down to 5 change values.</p>"},{"location":"math/equipartition/","title":"Equipartition","text":"<p>An equipartition of a natural number \\(n\\) into \\(k\\) parts is a partition where all parts differ by at most 1.</p>"},{"location":"math/equipartition/#equipartitionnatural","title":"equipartitionNatural","text":"\\[ \\text{equipartitionNatural}(n, k) = [p_1, \\ldots, p_k] \\] <p>where:</p> \\[ p_i \\in \\left\\{ \\left\\lfloor \\frac{n}{k} \\right\\rfloor, \\left\\lceil \\frac{n}{k} \\right\\rceil \\right\\} \\quad\\text{and}\\quad \\sum_{i=1}^{k} p_i = n \\] <p>The result is sorted in ascending order.</p>"},{"location":"math/equipartition/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; equipartitionNatural 10 (() :| [(), ()])\n3 :| [3, 4]\n\n&gt;&gt;&gt; equipartitionNatural 7 (() :| [(), ()])\n2 :| [2, 3]\n</code></pre>"},{"location":"math/equipartition/#implementation","title":"Implementation","text":"<p><code>equipartitionNatural</code> is implemented as a special case of <code>partitionNatural</code> where all weights are 1:</p> <pre><code>equipartitionNatural n count =\n    NE.reverse $ fromMaybe zeroError $\n        partitionNatural n (1 &lt;$ count)\n</code></pre>"},{"location":"math/equipartition/#equipartitionquantitieswithupperbound","title":"equipartitionQuantitiesWithUpperBound","text":"<p>This function splits a <code>TokenBundle</code> into multiple bundles such that no individual token quantity exceeds a given upper bound.</p> <p>Given a bundle \\(b\\) and maximum quantity \\(q_{\\max}\\):</p> \\[ \\text{equipartitionQuantitiesWithUpperBound}(b, q_{\\max}) = [b_1, \\ldots, b_m] \\] <p>where:</p> <ul> <li>For each asset \\(a\\) and each \\(b_i\\): \\(\\text{qty}(b_i, a) \\leq q_{\\max}\\)</li> <li>\\(\\sum_i b_i = b\\) (the total is preserved)</li> <li>\\(m\\) is minimised</li> </ul> <p>The number of parts needed for a single asset with quantity \\(q\\) is:</p> \\[ m(q) = \\left\\lceil \\frac{q}{q_{\\max}} \\right\\rceil \\] <p>The overall number of parts is the maximum across all assets:</p> \\[ m = \\max_a \\left\\lceil \\frac{\\text{qty}(b, a)}{q_{\\max}} \\right\\rceil \\]"},{"location":"math/equipartition/#equipartitionassets","title":"equipartitionAssets","text":"<p>Splits a <code>TokenBundle</code> into \\(k\\) bundles by evenly distributing the assets (not quantities) across the parts, then equipartitioning each asset's quantity.</p> <p>This is used when a change output has too many distinct assets to fit in a single transaction output. The bundle is repeatedly halved until each part is within the size limit.</p>"},{"location":"math/equipartition/#usage-in-coin-selection","title":"Usage in coin selection","text":"<p>These functions are used during change generation to split oversized change outputs:</p> <ol> <li> <p><code>splitBundlesWithExcessiveAssetCounts</code> -- uses <code>equipartitionAssets</code>    to split bundles that exceed the maximum token bundle size.</p> </li> <li> <p><code>splitBundlesWithExcessiveTokenQuantities</code> -- uses    <code>equipartitionQuantitiesWithUpperBound</code> to split bundles containing    quantities that exceed the protocol maximum.</p> </li> </ol>"},{"location":"math/partial-orders/","title":"Partial Orders","text":"<p>The <code>TokenMap</code> and <code>TokenBundle</code> types use partial ordering instead of total ordering. This page explains why, and how partial orders are used in the coin selection algorithm.</p>"},{"location":"math/partial-orders/#why-no-ord-instance","title":"Why no Ord instance?","text":"<p>Consider two token maps:</p> <pre><code>p = fromFlatList [(assetA, 2), (assetB, 1)]\nq = fromFlatList [(assetA, 1), (assetB, 2)]\n</code></pre> <p>Neither \\(p \\leq q\\) nor \\(q \\leq p\\) holds -- they are incomparable.</p> <p>A total ordering (like lexicographic) could be defined, but it would not be consistent with the arithmetic properties of token maps. For example, under lexicographic ordering we might have \\(p &gt; q\\), but we could not conclude that \\(p - q\\) is non-negative (it would be \\((1, -1)\\), which is not a valid token map).</p> <p>Type error on Ord</p> <p>Both <code>TokenMap</code> and <code>TokenBundle</code> generate a compile-time type error if you try to use them with <code>Ord</code>:</p> <pre><code>Ord not supported for token maps\nOrd not supported for token bundles\n</code></pre> <p>This prevents accidental misuse.</p>"},{"location":"math/partial-orders/#the-partial-order","title":"The partial order","text":"<p>The <code>PartialOrd</code> instance defines:</p> \\[ x \\leq y \\iff \\forall\\, a: \\text{qty}(x, a) \\leq \\text{qty}(y, a) \\] <p>In Haskell:</p> <pre><code>instance PartialOrd TokenMap where\n    leq = MonoidMap.isSubmapOf `on` unTokenMap\n</code></pre>"},{"location":"math/partial-orders/#examples","title":"Examples","text":"<pre><code>x = fromFlatList [(assetA, 1)]\ny = fromFlatList [(assetA, 2), (assetB, 1)]\n-- x `leq` y  ==  True  (x is strictly less than y)\n\np = fromFlatList [(assetA, 2), (assetB, 1)]\nq = fromFlatList [(assetA, 1), (assetB, 2)]\n-- p `leq` q  ==  False (incomparable)\n-- q `leq` p  ==  False (incomparable)\n</code></pre>"},{"location":"math/partial-orders/#tokenbundle-partial-order","title":"TokenBundle partial order","text":"<p>For <code>TokenBundle</code>, which combines a <code>Coin</code> with a <code>TokenMap</code>:</p> \\[ (c_1, m_1) \\leq (c_2, m_2) \\iff c_1 \\leq c_2 \\land m_1 \\leq m_2 \\] <pre><code>instance PartialOrd TokenBundle where\n    b1 `leq` b2 =\n        (&amp;&amp;)\n            (coin b1 &lt;= coin b2)\n            (tokens b1 `leq` tokens b2)\n</code></pre>"},{"location":"math/partial-orders/#lexicographic-ordering-when-needed","title":"Lexicographic ordering (when needed)","text":"<p>When an arbitrary total ordering is needed (e.g., for use as a <code>Map</code> key or <code>Set</code> element), both types provide a <code>Lexicographic</code> newtype:</p> <pre><code>newtype Lexicographic a = Lexicographic { unLexicographic :: a }\n\ninstance Ord (Lexicographic TokenMap) where\n    compare = comparing (toNestedList . unLexicographic)\n</code></pre>"},{"location":"math/partial-orders/#usage-in-coin-selection","title":"Usage in coin selection","text":"<p>The partial order is fundamental to the change generation algorithm:</p> <ul> <li> <p>Ascending partial order of change maps: the non-user-specified change   maps are maintained in ascending partial order, which ensures that when   combined with user-specified change, the smallest maps are paired with the   smallest.</p> </li> <li> <p>Balance sufficiency check: the algorithm checks whether the available   UTxO balance is sufficient by verifying that the required balance is less   than or equal (in the partial order) to the available balance.</p> </li> <li> <p>Selection delta: the surplus/deficit of a selection is computed using   the truncated subtraction \\((\\backslash\\!\\!&gt;)\\), which is the monus operation   on the partial order.</p> </li> </ul>"},{"location":"math/partial-orders/#the-inascendingpartialorder-predicate","title":"The <code>inAscendingPartialOrder</code> predicate","text":"<p>The <code>Cardano.CoinSelection.Internal.Numeric</code> module provides:</p> <pre><code>inAscendingPartialOrder :: (Foldable f, PartialOrd a) =&gt; f a -&gt; Bool\n</code></pre> <p>This checks that consecutive pairs satisfy <code>leq</code>, and is used in property tests to verify that change maps are correctly ordered.</p>"},{"location":"math/partitioning/","title":"Partitioning Natural Numbers","text":"<p>The <code>partitionNatural</code> function from <code>Cardano.CoinSelection.Internal.Numeric</code> distributes a natural number into parts proportional to a list of weights. It is used throughout the coin selection algorithm to split quantities fairly.</p>"},{"location":"math/partitioning/#definition","title":"Definition","text":"<p>Given a target \\(n \\in \\mathbb{N}\\) and weights \\(w_1, w_2, \\ldots, w_k\\) with \\(W = \\sum_i w_i &gt; 0\\):</p> \\[ \\text{partitionNatural}(n, [w_1, \\ldots, w_k]) = [p_1, \\ldots, p_k] \\] <p>where each \\(p_i\\) is within unity of the ideal proportion:</p> \\[ \\left| p_i - n \\cdot \\frac{w_i}{W} \\right| &lt; 1 \\]"},{"location":"math/partitioning/#algorithm","title":"Algorithm","text":"<p>The algorithm computes the partition in five steps:</p>"},{"location":"math/partitioning/#step-1-compute-ideal-rational-proportions","title":"Step 1: Compute ideal (rational) proportions","text":"\\[ q_i = n \\cdot \\frac{w_i}{W} \\in \\mathbb{Q} \\]"},{"location":"math/partitioning/#step-2-attach-indices","title":"Step 2: Attach indices","text":"<p>Associate each \\(q_i\\) with its original position \\(i\\) so the ordering can be restored later.</p>"},{"location":"math/partitioning/#step-3-sort-by-fractional-part","title":"Step 3: Sort by fractional part","text":"<p>Sort the indexed proportions in descending order of their fractional parts \\(\\{q_i\\}\\), breaking ties by descending integral part \\(\\lfloor q_i \\rfloor\\).</p>"},{"location":"math/partitioning/#step-4-apply-roundings","title":"Step 4: Apply roundings","text":"<p>Compute the shortfall:</p> \\[ s = n - \\sum_{i=1}^{k} \\lfloor q_i \\rfloor \\] <p>Round up the first \\(s\\) elements (those with the largest fractional parts) and round down the rest:</p> \\[ p_{\\sigma(i)} = \\begin{cases} \\lceil q_{\\sigma(i)} \\rceil &amp; \\text{if } i \\leq s \\\\ \\lfloor q_{\\sigma(i)} \\rfloor &amp; \\text{if } i &gt; s \\end{cases} \\] <p>where \\(\\sigma\\) is the permutation from step 3.</p>"},{"location":"math/partitioning/#step-5-restore-original-order","title":"Step 5: Restore original order","text":"<p>Sort by the original indices to produce the final result.</p>"},{"location":"math/partitioning/#guarantees","title":"Guarantees","text":"<ol> <li> <p>Length preservation: \\(|\\text{result}| = |\\text{weights}|\\)</p> </li> <li> <p>Sum preservation: \\(\\sum_i p_i = n\\)</p> </li> <li> <p>Proportionality: each \\(p_i\\) is within 1 of the ideal proportion</p> </li> <li> <p>Non-negative: all \\(p_i \\geq 0\\)</p> </li> </ol>"},{"location":"math/partitioning/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; partitionNatural 9 (1 :| [1, 1])\nJust (3 :| [3, 3])\n\n&gt;&gt;&gt; partitionNatural 10 (1 :| [])\nJust (10 :| [])\n\n&gt;&gt;&gt; partitionNatural 30 (1 :| [2, 4, 8])\nJust (2 :| [4, 8, 16])\n</code></pre>"},{"location":"math/partitioning/#usage-in-coin-selection","title":"Usage in coin selection","text":"<p>The <code>partitionNatural</code> function is used in several places:</p> <ul> <li> <p><code>makeChangeForCoin</code>: distributes surplus ada across change outputs   proportionally to the original output coin values.</p> </li> <li> <p><code>makeChangeForUserSpecifiedAsset</code>: distributes surplus token quantities   across change outputs proportionally to the original output quantities of   that asset.</p> </li> <li> <p><code>equipartitionNatural</code>: a special case where all weights are equal,   producing an equipartition.</p> </li> </ul>"}]}